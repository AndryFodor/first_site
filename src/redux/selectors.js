import { createSelector } from "reselect";

// Припустимо, що в нас є якась логіка, і нам потрібно отримати не всіх користувачів, а лише тих, які підпадають під певні умови, тобто нам треба відфільтрувати отриманий масив за певною умовою. Скориставшись методом filter ми отримаємо новий масив. Якщо навіть саме тут змін не відбулося, а в якомусь іншому місці (action FAKE, але це лише для демонстрації, насправді для цієї сторінки можуть оброблятися якісь окремі дані, в результаті яких не мало б бути перемальовки, а вона буде), то це призведе до виконання функції mapStateToProps, і відповідно буде отриманий інший масив з тими самими значеннями. Але оскільки масив новий, то в такому випадку відбудеться ререндер сторінки, хоча змін ми не побачимо. А така ситуація доволі ресурсозатранта. Тому бажано якось виправити цю ситуацію. В цьому може допомогти функція createSelector з бібліотеки reselect (щоб це побачити, треба розкоментувати setInterval в index.js)
// export const selectUsers = state => state.usersPage.users.filter(value => true);
const selectUsers = state => state.usersPage.users;
export const selectIsFetching = state => state.usersPage.isFetching;

// Функція createSelector приймає першими парметрами прості селестори, які виконують вибірку певний даних, які необхідно обробити, щоб повернути зdідси необхідний результат. Селектор буде залежати саме від їхніх даних і перевірятиме їх перед власним запуском. Останнім параметром ця функція приймає коллбек. В параметрах цей коллбек приймає дані, від яких буде залежати, в залежності від яких треба або не треба робити ререндерінг (ці дані передаватимуть примітивні селектори, які йдуть першими параметрами відповідно). Далі в тілі цього коллбеку виконуються необхідні обчислення і повертається результат. При завантаженні сторінки ця логіка буде виконана і будуть створені змінні, які зберігатимуть ті дані, які були отримані (від яких залежить перемальовка) та результат. При подальших змінах в стейті цей селектор не відразу почне працювати і повертати псевдонове значення в гіршому випадку, а спочатку звірить вхідні дані з відповідними закешованими, і якщо вони будуть рівними, то в такому випадку функція не виконуватиме знову всієї логіки обробки даних, а просто візьме закешований результат і поверне його. Хай то буде число, хай то буде масив чи об'єкт, вони будуть рівні попередньому значенню. А значить не відбуватиметься непотрібна перемальовка. Повертає ця функція ще одну функцію, в яку треба передавати стейт. Такий інтерфейс робить її простою у використанні на стороні компоненти (UI) і ефективною на стороні BLL. А всередині себе отримана функція виконуватиме описану логіку. Тепер, після застосування відповідної функції, проблема буде вирішина. І скільки б не змінювався стейт (фейкове значення змінюється щосекунди), цей селектор звірить попередні дані з "новими", і, зрозумівши, шо вони такі самі, поверне той самий масив, що закешувався в результаті обробки уих самих значень, а не новий.
export const getUsers = createSelector( selectUsers, selectIsFetching, (users, isFetching) => {
    // some difficult and long calculating ... .. . .. ... .. .. .
    let weUseValuesOfWhichWeAreDepended = isFetching;
    console.log(`Reselector has worked. It depended of two selections: isFetchin that is equel ${weUseValuesOfWhichWeAreDepended} and of array of users, which you can see`);
    return users.filter(value => true);
} )


export const selectAllUsersCount = state => state.usersPage.allUsersCount;
export const selectUsersPerPage = state => state.usersPage.usersCountForPage;
export const selectPage = state => state.usersPage.selectedPage;
export const selectNextBotton = state => state.usersPage.nextButon;
export const selectBackBotton = state => state.usersPage.backBottom;
export const selectPortionOfPages = state => state.usersPage.portionOfPages;
export const selectFollowingIsFetching = state => state.usersPage.followingInProgress;

// при такій простій логіці селекторів не виникає жодних проблем. Але якщо в них буде більше логіки, якихось обчислень, чи навіть простої фільтрації (або якимось подібним методом, який повертає новий масив), то в такому випадку виникатиме проблема постійної перемальовки сторінки. Або якщо щось несуттєве для інтерфейсу в стейті задіспатчилося, то виконається весь mapStateToProps, і виконає всю логіку, щою зрівняти, змінилися дані чи ні? Якщо хоч одне дане змінилося, то відбувається перемальовка. Щоб уникнути такої ситуації, треба застосувати бібліотеку reselect, вона має вирішити її